-- ITEMS QUERY 1 - NOT STONKS
SELECT  
    c.NAME_CROP AS CROP_NAME,
    s.SEED_TYPE AS TYPE,
    i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
    i.PRICE_TO_SELL AS PRICE_TO_SELL,
    ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY) * 100 / i.PRICE_TO_BUY, 2) AS PRICE_DIFFERENCE
FROM CROP c
    JOIN SEED s ON s.NAME_CROP = c.NAME_CROP
    JOIN ITEM i ON i.ID_ITEM = s.ID_SEED
WHERE UPPER(c.QUALITY) = 'COOPER'
    AND i.PRICE_TO_BUY IS NOT NULL
    AND i.PRICE_TO_SELL IS NOT NULL
    AND i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 1 - NOT STONKS - Sol2
SELECT c.NAME_CROP AS CROP_NAME,
       s.SEED_TYPE AS TYPE,
       i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
       i.PRICE_TO_SELL AS PRICE_TO_SELL,
       ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY)*100/i.PRICE_TO_BUY,2) AS PRICE_DIFFERENCE
FROM   ITEM i
    LEFT JOIN SEED s ON s.ID_SEED   = i.ID_ITEM
    LEFT JOIN CROP c ON c.NAME_CROP = s.NAME_CROP
WHERE  UPPER(c.QUALITY) = 'COOPER'
  AND  i.PRICE_TO_BUY  IS NOT NULL
  AND  i.PRICE_TO_SELL IS NOT NULL
  AND  i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 2 - ITEM POPULARITY
SELECT  
    sh.NAME_SHOP AS STORE_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    it.NAME AS ITEM_NAME,
    SUM(bs.AMOUNT) AS NUM_PURCHASES
FROM BUY_SELL bs
    JOIN (
        SELECT ID_ITEM
        FROM BUY_SELL
        WHERE ACTION = 'BUY'
        GROUP BY ID_ITEM
        ORDER BY SUM(AMOUNT) DESC
        FETCH FIRST 1 ROW ONLY
    ) best ON best.ID_ITEM = bs.ID_ITEM
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
GROUP BY sh.NAME_SHOP, sh.SPECIALIZATION, it.NAME
ORDER BY NUM_PURCHASES DESC, sh.NAME_SHOP;

-- ITEMS QUERY 3 - CUTTING IT CLOSE
SELECT  
    sh.NAME_SHOP AS SHOP_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    pl.NICKNAME AS PLAYER_NAME,
    it.NAME AS ITEM_NAME,
    bs.AMOUNT AS AMOUNT,
    ABS(bs.MONEY_FLUCTUATION) AS GOLD_EXPENDED,
    TRUNC(bs.ACTION_TIME) AS DATE_OF_PURCHASE
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
    AND EXTRACT(MONTH FROM bs.ACTION_TIME) = 12
    AND bs.ACTION_TIME = (
        SELECT MAX(bs2.ACTION_TIME)
        FROM BUY_SELL bs2
        WHERE bs2.ACTION = 'BUY'
          AND TRUNC(bs2.ACTION_TIME) = TRUNC(bs.ACTION_TIME)
    )
ORDER BY DATE_OF_PURCHASE;

-- ITEMS QUERY 4 - SPARE NO EXPENSE
SELECT  
    i1.NAME AS ITEM1,
    i2.NAME AS ITEM2,
    (f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) AS TOTAL_HEALTH
FROM FOOD f1
    JOIN FOOD f2 ON f1.ID_FOOD < f2.ID_FOOD
    JOIN ITEM i1 ON i1.ID_ITEM = f1.ID_FOOD
    JOIN ITEM i2 ON i2.ID_ITEM = f2.ID_FOOD
ORDER BY ABS((f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) - 100)
FETCH FIRST 20 ROWS ONLY;

-- ITEMS QUERY 5 - THE BEST PLACES
SELECT  
    p.LOCATION_NAME AS LOCATION_NAME,
    COUNT(*) AS TRANSACTION_COUNT
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLACE p ON p.ID_PLACE = sh.ID_PLACE
WHERE ABS(bs.MONEY_FLUCTUATION) > 200
GROUP BY p.LOCATION_NAME
ORDER BY TRANSACTION_COUNT DESC;

-- ITEMS QUERY 6 - ITEM SALE
SELECT  
    ITEM_NAME,
    SHOP,
    PLAYER_NAME,
    ROUND(UNIT_PRICE - BASELINE_PRICE, 2) AS MONEY_EARNED_OVER_BASE
FROM (
    SELECT  
        it.NAME AS ITEM_NAME,
        sh.NAME_SHOP AS SHOP,
        pl.NICKNAME AS PLAYER_NAME,
        ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT AS UNIT_PRICE,
        MIN(it.PRICE_TO_SELL) OVER (PARTITION BY it.NAME) AS BASELINE_PRICE,
        MAX(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT) OVER (PARTITION BY it.NAME, pl.NICKNAME) AS MAX_PRICE,
        MIN(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT) OVER (PARTITION BY it.NAME, pl.NICKNAME) AS MIN_PRICE
    FROM BUY_SELL bs
        JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
        JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
        JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
    WHERE bs.ACTION = 'SELL'
      AND bs.AMOUNT > 0
)
WHERE UNIT_PRICE = MAX_PRICE
   OR UNIT_PRICE = MIN_PRICE
ORDER BY ITEM_NAME, PLAYER_NAME, MONEY_EARNED_OVER_BASE DESC;

-- ITEMS Q-6 â€“ Using IDs (Explained in report)
/*
SELECT  
    it.NAME AS ITEM_NAME,
    sh.NAME_SHOP AS SHOP,
    pl.NICKNAME AS PLAYER_NAME,
    ROUND(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT - it.PRICE_TO_SELL, 2) AS MONEY_EARNED_OVER_BASE
FROM BUY_SELL bs
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
WHERE bs.ACTION = 'SELL'
  AND bs.AMOUNT > 0
  AND (
        ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT = (
            SELECT MAX(ABS(bs2.MONEY_FLUCTUATION) / bs2.AMOUNT)
            FROM BUY_SELL bs2
            WHERE bs2.ACTION = 'SELL'
              AND bs2.AMOUNT > 0
              AND bs2.ID_ITEM = bs.ID_ITEM
              AND bs2.ID_PLAYER = bs.ID_PLAYER
        )
     OR ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT = (
            SELECT MIN(ABS(bs3.MONEY_FLUCTUATION) / bs3.AMOUNT)
            FROM BUY_SELL bs3
            WHERE bs3.ACTION = 'SELL'
              AND bs3.AMOUNT > 0
              AND bs3.ID_ITEM = bs.ID_ITEM
              AND bs3.ID_PLAYER = bs.ID_PLAYER
        )
  )
ORDER BY it.NAME, pl.NICKNAME, MONEY_EARNED_OVER_BASE DESC;
*/

-- TRIGGER
BEGIN
    EXECUTE IMMEDIATE 'DROP TRIGGER TRIGGER_1';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -4080 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE TRIGGER TRIGGER_1
AFTER INSERT ON BUY_SELL
FOR EACH ROW
WHEN (NEW.ACTION = 'BUY')
BEGIN
    UPDATE S_STORED
    SET QUANTITY = QUANTITY - :NEW.AMOUNT
    WHERE ID_SHOP = :NEW.ID_SHOP
      AND ID_ITEM = :NEW.ID_ITEM;

    MERGE INTO P_STORED p
    USING (
        SELECT :NEW.ID_PLAYER AS ID_PLAYER,
               :NEW.ID_ITEM AS ID_ITEM
        FROM DUAL
    ) src
    ON (p.ID_PLAYER = src.ID_PLAYER
        AND p.ID_ITEM = src.ID_ITEM)
    WHEN MATCHED THEN
        UPDATE SET p.QUANTITY = p.QUANTITY + :NEW.AMOUNT
    WHEN NOT MATCHED THEN
        INSERT (ID_PLAYER, ID_ITEM, QUANTITY)
        VALUES (src.ID_PLAYER, src.ID_ITEM, :NEW.AMOUNT);
END;
/
