
-- ITEMS QUERY 1 - NOT STONKS
SELECT  
    c.NAME_CROP AS CROP_NAME,
    s.SEED_TYPE AS TYPE,
    i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
    i.PRICE_TO_SELL AS PRICE_TO_SELL,
    ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY) * 100 / i.PRICE_TO_BUY, 2) AS PRICE_DIFFERENCE
FROM CROP c
    JOIN SEED s ON s.NAME_CROP = c.NAME_CROP
    JOIN ITEM i ON i.ID_ITEM = s.ID_SEED
WHERE UPPER(c.QUALITY) = 'COOPER'
    AND i.PRICE_TO_BUY IS NOT NULL
    AND i.PRICE_TO_SELL IS NOT NULL
    AND i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 1 - NOT STONKS - Sol2
SELECT c.NAME_CROP AS CROP_NAME,
       s.SEED_TYPE AS TYPE,
       i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
       i.PRICE_TO_SELL AS PRICE_TO_SELL,
       ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY)*100/i.PRICE_TO_BUY,2) AS PRICE_DIFFERENCE
FROM   ITEM i
    LEFT JOIN SEED s ON s.ID_SEED   = i.ID_ITEM
    LEFT JOIN CROP c ON c.NAME_CROP = s.NAME_CROP
WHERE  UPPER(c.QUALITY) = 'COOPER'
  AND  i.PRICE_TO_BUY  IS NOT NULL
  AND  i.PRICE_TO_SELL IS NOT NULL
  AND  i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 2 - ITEM POPULARITY
SELECT  
    sh.NAME_SHOP AS STORE_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    it.NAME AS ITEM_NAME,
    SUM(bs.AMOUNT) AS NUM_PURCHASES
FROM BUY_SELL bs
    JOIN (
        SELECT ID_ITEM
        FROM BUY_SELL
        WHERE ACTION = 'BUY'
        GROUP BY ID_ITEM
        ORDER BY SUM(AMOUNT) DESC
        FETCH FIRST 1 ROW ONLY
    ) best ON best.ID_ITEM = bs.ID_ITEM
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
GROUP BY sh.NAME_SHOP, sh.SPECIALIZATION, it.NAME
ORDER BY NUM_PURCHASES DESC, sh.NAME_SHOP;

-- ITEMS QUERY 3 - CUTTING IT CLOSE
SELECT  
    sh.NAME_SHOP AS SHOP_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    pl.NICKNAME AS PLAYER_NAME,
    it.NAME AS ITEM_NAME,
    bs.AMOUNT AS AMOUNT,
    ABS(bs.MONEY_FLUCTUATION) AS GOLD_EXPENDED,
    TRUNC(bs.ACTION_TIME) AS DATE_OF_PURCHASE
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
    AND EXTRACT(MONTH FROM bs.ACTION_TIME) = 12
    AND bs.ACTION_TIME = (
        SELECT MAX(bs2.ACTION_TIME)
        FROM BUY_SELL bs2
        WHERE bs2.ACTION = 'BUY'
          AND TRUNC(bs2.ACTION_TIME) = TRUNC(bs.ACTION_TIME)
    )
ORDER BY DATE_OF_PURCHASE;

-- ITEMS QUERY 4 - SPARE NO EXPENSE
SELECT  
    i1.NAME AS ITEM1,
    i2.NAME AS ITEM2,
    (f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) AS TOTAL_HEALTH
FROM FOOD f1
    JOIN FOOD f2 ON f1.ID_FOOD < f2.ID_FOOD
    JOIN ITEM i1 ON i1.ID_ITEM = f1.ID_FOOD
    JOIN ITEM i2 ON i2.ID_ITEM = f2.ID_FOOD
ORDER BY ABS((f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) - 100)
FETCH FIRST 20 ROWS ONLY;

-- ITEMS QUERY 5 - THE BEST PLACES
SELECT  
    p.LOCATION_NAME AS LOCATION_NAME,
    COUNT(*) AS TRANSACTION_COUNT
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLACE p ON p.ID_PLACE = sh.ID_PLACE
WHERE ABS(bs.MONEY_FLUCTUATION) > 200
GROUP BY p.LOCATION_NAME
ORDER BY TRANSACTION_COUNT DESC;

-- ITEMS QUERY 6 - ITEM SALE PRICE EXTREMES
SELECT  
    IT.NAME                          AS ITEM_NAME,
    SH.NAME_SHOP                     AS SHOP,
    PL.NICKNAME                      AS PLAYER_NAME,
    ROUND(
      ABS(BS.MONEY_FLUCTUATION) / BS.AMOUNT
      - IT.PRICE_TO_SELL
    , 2)                             AS MONEY_EARNED_OVER_BASE
FROM BUY_SELL BS
    JOIN ITEM   IT ON IT.ID_ITEM = BS.ID_ITEM
    JOIN SHOP   SH ON SH.ID_SHOP = BS.ID_SHOP
    JOIN PLAYER PL ON PL.ID_PLAYER = BS.ID_PLAYER
WHERE BS.ACTION = 'SELL'
    AND BS.AMOUNT > 0
    AND (
       ABS(BS.MONEY_FLUCTUATION) / BS.AMOUNT = (
         SELECT MAX(ABS(BS2.MONEY_FLUCTUATION) / BS2.AMOUNT)
         FROM   BUY_SELL BS2
         WHERE  BS2.ACTION = 'SELL'
           AND  BS2.AMOUNT >  0
           AND  BS2.ID_ITEM =  BS.ID_ITEM
       )
    OR 
       ABS(BS.MONEY_FLUCTUATION) / BS.AMOUNT = (
         SELECT MIN(ABS(BS3.MONEY_FLUCTUATION) / BS3.AMOUNT)
         FROM   BUY_SELL BS3
         WHERE  BS3.ACTION = 'SELL'
           AND  BS3.AMOUNT >  0
           AND  BS3.ID_ITEM=  BS.ID_ITEM
       )
  )
ORDER BY IT.NAME,MONEY_EARNED_OVER_BASE DESC;


-- TRIGGER
BEGIN
    EXECUTE IMMEDIATE 'DROP TRIGGER TRIGGER_1';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -4080 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE TRIGGER TRIGGER_1
AFTER INSERT ON BUY_SELL
FOR EACH ROW
WHEN (NEW.ACTION = 'BUY')
BEGIN
    UPDATE S_STORED
    SET QUANTITY = QUANTITY - :NEW.AMOUNT
    WHERE ID_SHOP = :NEW.ID_SHOP
      AND ID_ITEM = :NEW.ID_ITEM;
    MERGE INTO P_STORED p
    USING (
        SELECT :NEW.ID_PLAYER AS ID_PLAYER,
               :NEW.ID_ITEM AS ID_ITEM
        FROM DUAL
    ) src
    ON (p.ID_PLAYER = src.ID_PLAYER
        AND p.ID_ITEM = src.ID_ITEM)
    WHEN MATCHED THEN
        UPDATE SET p.QUANTITY = p.QUANTITY + :NEW.AMOUNT
    WHEN NOT MATCHED THEN
        INSERT (ID_PLAYER, ID_ITEM, QUANTITY)
        VALUES (src.ID_PLAYER, src.ID_ITEM, :NEW.AMOUNT);
END;
/
--QUERY 1) FARM
SELECT p.ID_PLAYER, p.NICKNAME AS NAME, AVG(pm.END_DATE - pm.START_DATE) AS AVG_TIMESPAN
FROM PLAYER_MISSION pm
JOIN PLAYER p ON p.ID_PLAYER = pm.ID_PLAYER
WHERE pm.IS_COMPLETED = 1 AND pm.END_DATE > pm.START_DATE
GROUP BY p.ID_PLAYER, p.NICKNAME
HAVING AVG(pm.END_DATE - pm.START_DATE) < (
    SELECT AVG(END_DATE - START_DATE)
    FROM PLAYER_MISSION
    WHERE IS_COMPLETED = 1 AND END_DATE > START_DATE
)
ORDER BY AVG_TIMESPAN ASC
FETCH FIRST 10 ROWS ONLY;

--QUERY 2) FARM
SELECT f.ID_FARM, f.SPECIALIZATION, COUNT(*) AS NUM_CROPS
FROM FARM f
JOIN FARMBUILDING fb ON fb.ID_FARM = f.ID_FARM
JOIN CULTIVATIONFIELD cf ON cf.ID_FIELD = fb.ID_FARM_BUILDING
JOIN GROW g ON g.ID_FIELD = cf.ID_FIELD
JOIN CROP c ON c.ID_CROP = g.ID_CROP
WHERE c.QUALITY = 'Gold'
GROUP BY f.ID_FARM, f.SPECIALIZATION
HAVING COUNT(*) = (
    SELECT MAX(GOLD_COUNT)
    FROM (
        SELECT f2.ID_FARM, COUNT(*) AS GOLD_COUNT
        FROM FARM f2
        JOIN FARMBUILDING fb2 ON fb2.ID_FARM = f2.ID_FARM
        JOIN CULTIVATIONFIELD cf2 ON cf2.ID_FIELD = fb2.ID_FARM_BUILDING
        JOIN GROW g2 ON g2.ID_FIELD = cf2.ID_FIELD
        JOIN CROP c2 ON c2.ID_CROP = g2.ID_CROP
        WHERE c2.QUALITY = 'Gold'
        GROUP BY f2.ID_FARM
    )
)
ORDER BY f.ID_FARM;

--FARM QUERY 3)
SELECT a.ID_BARN, a.ID_ANIMAL, a.NAME_ANIMAL AS ANIMAL_NAME, a.AGE, a.HEALTH AS HEALTH_STATUS, COUNT(p.ID_PRODUCT) AS NUM_PRODUCTS
FROM ANIMAL a
    JOIN PRODUCE p ON a.ID_ANIMAL = p.ID_ANIMAL
WHERE a.HEALTH = 'Healthy'
GROUP BY a.ID_BARN, a.ID_ANIMAL, a.NAME_ANIMAL, a.AGE, a.HEALTH
HAVING COUNT(p.ID_PRODUCT) > (
    SELECT AVG(prod_count)
    FROM (
        SELECT COUNT(p2.ID_PRODUCT) AS prod_count
            FROM ANIMAL a2
                JOIN PRODUCE p2 ON a2.ID_ANIMAL = p2.ID_ANIMAL
            WHERE a2.ID_BARN = a.ID_BARN
            GROUP BY a2.ID_ANIMAL
  )
)
ORDER BY a.ID_BARN, a.ID_ANIMAL;

--FARM QUERY 4)
SELECT f.ID_FARM, f.HECTARES, SUM(fb.BUILDING_SIZE) AS OCCUPIED_SPACE, f.HECTARES - SUM(fb.BUILDING_SIZE) AS SPACE_LEFT,
    COUNT(*) AS NUM_BUILDINGS,
    FLOOR((f.HECTARES - SUM(fb.BUILDING_SIZE)) / MIN(fb.BUILDING_SIZE)) AS NUM_NEW_BUILDINGS
FROM FARM f
    JOIN FARMBUILDING fb ON f.ID_FARM = fb.ID_FARM
GROUP BY f.ID_FARM, f.HECTARES
HAVING f.HECTARES < 600000 AND (f.HECTARES - SUM(fb.BUILDING_SIZE)) > 0
ORDER BY f.ID_FARM;

--FARM QUERY 5)
SELECT p.ID_PLAYER, p.NICKNAME AS NAME, b.ID_BARN AS ID_BARN_BUILDING, COUNT(DISTINCT a.ID_ANIMAL_SPECIE) AS SPECIES_COUNT
FROM PLAYER p
    JOIN FARM f ON f.ID_PLAYER = p.ID_PLAYER
    JOIN FARMBUILDING fb ON fb.ID_FARM = f.ID_FARM
    JOIN BARN b ON b.ID_BARN = fb.ID_FARM_BUILDING
    JOIN ANIMAL a ON a.ID_BARN = b.ID_BARN
WHERE p.ID_PLAYER NOT IN (
    SELECT DISTINCT ID_PLAYER
        FROM PLAYER_MISSION
        WHERE IS_COMPLETED = 1
)
GROUP BY p.ID_PLAYER, p.NICKNAME, b.ID_BARN
HAVING COUNT(DISTINCT a.ID_ANIMAL_SPECIE) > 1
ORDER BY b.ID_BARN;

--FARM QUERY 5)
SELECT ID_PLAYER, NICKNAME AS NAME, GOLD, EXPERIENCE
FROM PLAYER
WHERE EXPERIENCE > (
    SELECT EXPERIENCE FROM (
        SELECT EXPERIENCE, ROWNUM AS RN
        FROM (
            SELECT EXPERIENCE
            FROM PLAYER
            ORDER BY EXPERIENCE
        )
    )
  WHERE RN = CEIL((SELECT COUNT(*) FROM PLAYER) * 0.97)
)
AND GOLD > (SELECT AVG(GOLD) FROM PLAYER)
ORDER BY GOLD DESC;

-- TRIGGER FOR FARMS
BEGIN
    EXECUTE IMMEDIATE 'DROP TRIGGER TRIGGER_CHECK_CAPACITY_BARN';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -4080 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE TRIGGER TRIGGER_CHECK_CAPACITY_BARN
BEFORE INSERT ON ANIMAL
FOR EACH ROW
DECLARE
    max_cap   NUMBER;
    occ_spots NUMBER;
BEGIN
    SELECT MAX_CAPACITY, OCCUPIED_SPOTS
    INTO max_cap, occ_spots
    FROM BARN
    WHERE ID_BARN = :NEW.ID_BARN;

    IF occ_spots >= max_cap THEN
        --setting to null so it will throw an error
        :NEW.ID_ANIMAL := NULL;  
    ELSE
        UPDATE BARN
        SET OCCUPIED_SPOTS = OCCUPIED_SPOTS + 1
        WHERE ID_BARN = :NEW.ID_BARN;
    END IF;
END TRIGGER_CHECK_CAPACITY_BARN;
/

-- VILLAGE QUERIES

-- QUERY 1
SELECT 
    c.NAME, 
    ROUND(AVG(r.AFFECTION_LEVEL), 2) AS AVG_POINTS, 
    COUNT(*) AS TOTAL_RELATIONSHIPS 
FROM ( 
    SELECT ID_CHARACTER1 AS ID_CHARACTER, AFFECTION_LEVEL FROM RELATIONSHIP 
    UNION ALL 
    SELECT ID_CHARACTER2 AS ID_CHARACTER, AFFECTION_LEVEL FROM RELATIONSHIP 
) r 
JOIN CHARACTER c ON c.ID_CHARACTER = r.ID_CHARACTER 
GROUP BY c.ID_CHARACTER, c.NAME 
HAVING COUNT(*) = (   
        SELECT MAX(cnt) 
        FROM (SELECT ID_RESIDENT, COUNT(*) AS cnt 
            FROM (SELECT ID_CHARACTER1 AS ID_RESIDENT FROM RELATIONSHIP 
                    UNION ALL 
                    SELECT ID_CHARACTER2 FROM RELATIONSHIP) GROUP BY ID_RESIDENT)) 
ORDER  BY TOTAL_RELATIONSHIPS DESC, c.NAME; 

-- QUERY 2
SELECT  c1.name  AS resident1, 
        c1.age AS age_resident_1, 
        c2.name AS resident2, 
        c2.age AS age_resident_2, 
        r.affection_level AS relation_points 
FROM relationship r 
JOIN character c1 ON c1.id_character = r.id_character1 
JOIN character c2 ON c2.id_character = r.id_character2 
WHERE r.affection_level < 10                   
    AND ( c1.age >= 3 * c2.age 
        OR c2.age >= 3 * c1.age ) 
ORDER BY relation_points ASC, resident1, resident2; 

-- QUERY 3

SELECT r.id_inhabitant AS id_resident, 
        r.id_player AS id_player, 
        l.id_item AS id_item 
FROM receive r 
JOIN letter l ON l.id_letter = r.id_letter 
WHERE l.id_item IS NOT NULL 
    AND l.id_item IN ( 
        SELECT id_item 
        FROM (SELECT l2.id_item, COUNT(*) AS cnt 
                FROM receive r2 
                JOIN letter l2 ON l2.id_letter = r2.id_letter 
                WHERE l2.id_item IS NOT NULL 
                GROUP BY l2.id_item ) 
        WHERE cnt = (                        
                SELECT MAX(cnt) 
                FROM (SELECT COUNT(*) AS cnt 
                        FROM receive r3 
                        JOIN letter l3 ON l3.id_letter = r3.id_letter 
                        WHERE l3.id_item IS NOT NULL 
                        GROUP BY l3.id_item ) ) 
    ) 
ORDER BY id_resident, id_player; 

-- QUERY 4

SELECT t.id_inhabitant AS id_resident, 
        COUNT(*) AS late_activities 
FROM (SELECT h.id_inhabitant, 
           (TO_NUMBER(SUBSTR(s.start_time,1,2))*60 + TO_NUMBER(SUBSTR(s.start_time,4,2)) ) AS start_min, 
           (TO_NUMBER(SUBSTR(s.end_time,1,2))*60 + TO_NUMBER(SUBSTR(s.end_time,4,2))) AS end_min 
        FROM has h 
        JOIN schedule s ON s.id_schedule = h.id_schedule 
      ) t 
WHERE t.start_min > 0                                      
    AND t.start_min < (SELECT AVG(TO_NUMBER(SUBSTR(start_time,1,2))*60 + TO_NUMBER(SUBSTR(start_time,4,2))) FROM schedule)                     
    AND t.start_min > t.end_min                               
GROUP BY t.id_inhabitant 
ORDER BY late_activities DESC, id_resident; 

-- QUERY 5

SELECT name 

FROM ( 
    SELECT c.name 
    FROM inhabitant i 
    JOIN character c ON c.id_character = i.id_inhabitant 
    WHERE EXTRACT(month FROM i.birthday) = 7      
        AND EXTRACT(year  FROM i.birthday) = 1999 
    UNION               
    SELECT  c.name 
    FROM player p 
    JOIN character c ON c.id_character = p.id_player 
    WHERE p.gold >= 2 * (SELECT AVG(gold) FROM player) 
)                                                        
ORDER BY name;

-- QUERY 6

SELECT c.name 
FROM inhabitant  i 
JOIN character c ON c.id_character = i.id_inhabitant 
LEFT JOIN relationship r1 ON r1.id_character1 = i.id_inhabitant 
LEFT JOIN relationship r2 ON r2.id_character2 = i.id_inhabitant 
WHERE r1.id_character1 IS NULL          
    AND r2.id_character2 IS NULL           
ORDER BY c.name;

-- TRIGGER

CREATE OR REPLACE TRIGGER trg_personality_boost 
AFTER UPDATE OF personality ON inhabitant 
FOR EACH ROW 
WHEN  (OLD.personality <> NEW.personality)      
BEGIN 
    UPDATE relationship 
       SET affection_level = affection_level + 1 
     WHERE id_character1 = :NEW.id_inhabitant 
        OR id_character2 = :NEW.id_inhabitant; 
END; 
/ 