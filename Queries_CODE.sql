-- ITEMS QUERY 1 - NOT STONKS
SELECT  
    c.NAME_CROP AS CROP_NAME,
    s.SEED_TYPE AS TYPE,
    i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
    i.PRICE_TO_SELL AS PRICE_TO_SELL,
    ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY) * 100 / i.PRICE_TO_BUY, 2) AS PRICE_DIFFERENCE
FROM CROP c
    JOIN SEED s ON s.NAME_CROP = c.NAME_CROP
    JOIN ITEM i ON i.ID_ITEM = s.ID_SEED
WHERE UPPER(c.QUALITY) = 'COOPER'
    AND i.PRICE_TO_BUY IS NOT NULL
    AND i.PRICE_TO_SELL IS NOT NULL
    AND i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 1 - NOT STONKS - Sol2
SELECT c.NAME_CROP AS CROP_NAME,
       s.SEED_TYPE AS TYPE,
       i.PRICE_TO_BUY AS PRICE_TO_BUY_NORMAL,
       i.PRICE_TO_SELL AS PRICE_TO_SELL,
       ROUND((i.PRICE_TO_SELL - i.PRICE_TO_BUY)*100/i.PRICE_TO_BUY,2) AS PRICE_DIFFERENCE
FROM   ITEM i
    LEFT JOIN SEED s ON s.ID_SEED   = i.ID_ITEM
    LEFT JOIN CROP c ON c.NAME_CROP = s.NAME_CROP
WHERE  UPPER(c.QUALITY) = 'COOPER'
  AND  i.PRICE_TO_BUY  IS NOT NULL
  AND  i.PRICE_TO_SELL IS NOT NULL
  AND  i.PRICE_TO_SELL < i.PRICE_TO_BUY
ORDER BY PRICE_DIFFERENCE ASC;

-- ITEMS QUERY 2 - ITEM POPULARITY
SELECT  
    sh.NAME_SHOP AS STORE_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    it.NAME AS ITEM_NAME,
    SUM(bs.AMOUNT) AS NUM_PURCHASES
FROM BUY_SELL bs
    JOIN (
        SELECT ID_ITEM
        FROM BUY_SELL
        WHERE ACTION = 'BUY'
        GROUP BY ID_ITEM
        ORDER BY SUM(AMOUNT) DESC
        FETCH FIRST 1 ROW ONLY
    ) best ON best.ID_ITEM = bs.ID_ITEM
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
GROUP BY sh.NAME_SHOP, sh.SPECIALIZATION, it.NAME
ORDER BY NUM_PURCHASES DESC, sh.NAME_SHOP;

-- ITEMS QUERY 3 - CUTTING IT CLOSE
SELECT  
    sh.NAME_SHOP AS SHOP_NAME,
    sh.SPECIALIZATION AS SPECIALIZATION,
    pl.NICKNAME AS PLAYER_NAME,
    it.NAME AS ITEM_NAME,
    bs.AMOUNT AS AMOUNT,
    ABS(bs.MONEY_FLUCTUATION) AS GOLD_EXPENDED,
    TRUNC(bs.ACTION_TIME) AS DATE_OF_PURCHASE
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
WHERE bs.ACTION = 'BUY'
    AND EXTRACT(MONTH FROM bs.ACTION_TIME) = 12
    AND bs.ACTION_TIME = (
        SELECT MAX(bs2.ACTION_TIME)
        FROM BUY_SELL bs2
        WHERE bs2.ACTION = 'BUY'
          AND TRUNC(bs2.ACTION_TIME) = TRUNC(bs.ACTION_TIME)
    )
ORDER BY DATE_OF_PURCHASE;

-- ITEMS QUERY 4 - SPARE NO EXPENSE
SELECT  
    i1.NAME AS ITEM1,
    i2.NAME AS ITEM2,
    (f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) AS TOTAL_HEALTH
FROM FOOD f1
    JOIN FOOD f2 ON f1.ID_FOOD < f2.ID_FOOD
    JOIN ITEM i1 ON i1.ID_ITEM = f1.ID_FOOD
    JOIN ITEM i2 ON i2.ID_ITEM = f2.ID_FOOD
ORDER BY ABS((f1.HEALTH_REGAIN + f2.HEALTH_REGAIN) - 100)
FETCH FIRST 20 ROWS ONLY;

-- ITEMS QUERY 5 - THE BEST PLACES
SELECT  
    p.LOCATION_NAME AS LOCATION_NAME,
    COUNT(*) AS TRANSACTION_COUNT
FROM BUY_SELL bs
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLACE p ON p.ID_PLACE = sh.ID_PLACE
WHERE ABS(bs.MONEY_FLUCTUATION) > 200
GROUP BY p.LOCATION_NAME
ORDER BY TRANSACTION_COUNT DESC;

-- ITEMS QUERY 6 - ITEM SALE
SELECT  
    ITEM_NAME,
    SHOP,
    PLAYER_NAME,
    ROUND(UNIT_PRICE - BASELINE_PRICE, 2) AS MONEY_EARNED_OVER_BASE
FROM (
    SELECT  
        it.NAME AS ITEM_NAME,
        sh.NAME_SHOP AS SHOP,
        pl.NICKNAME AS PLAYER_NAME,
        ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT AS UNIT_PRICE,
        MIN(it.PRICE_TO_SELL) OVER (PARTITION BY it.NAME) AS BASELINE_PRICE,
        MAX(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT) OVER (PARTITION BY it.NAME, pl.NICKNAME) AS MAX_PRICE,
        MIN(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT) OVER (PARTITION BY it.NAME, pl.NICKNAME) AS MIN_PRICE
    FROM BUY_SELL bs
        JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
        JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
        JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
    WHERE bs.ACTION = 'SELL'
      AND bs.AMOUNT > 0
)
WHERE UNIT_PRICE = MAX_PRICE
   OR UNIT_PRICE = MIN_PRICE
ORDER BY ITEM_NAME, PLAYER_NAME, MONEY_EARNED_OVER_BASE DESC;

-- ITEMS Q-6 â€“ Using IDs (Explained in report)
/*
SELECT  
    it.NAME AS ITEM_NAME,
    sh.NAME_SHOP AS SHOP,
    pl.NICKNAME AS PLAYER_NAME,
    ROUND(ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT - it.PRICE_TO_SELL, 2) AS MONEY_EARNED_OVER_BASE
FROM BUY_SELL bs
    JOIN ITEM it ON it.ID_ITEM = bs.ID_ITEM
    JOIN SHOP sh ON sh.ID_SHOP = bs.ID_SHOP
    JOIN PLAYER pl ON pl.ID_PLAYER = bs.ID_PLAYER
WHERE bs.ACTION = 'SELL'
  AND bs.AMOUNT > 0
  AND (
        ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT = (
            SELECT MAX(ABS(bs2.MONEY_FLUCTUATION) / bs2.AMOUNT)
            FROM BUY_SELL bs2
            WHERE bs2.ACTION = 'SELL'
              AND bs2.AMOUNT > 0
              AND bs2.ID_ITEM = bs.ID_ITEM
              AND bs2.ID_PLAYER = bs.ID_PLAYER
        )
     OR ABS(bs.MONEY_FLUCTUATION) / bs.AMOUNT = (
            SELECT MIN(ABS(bs3.MONEY_FLUCTUATION) / bs3.AMOUNT)
            FROM BUY_SELL bs3
            WHERE bs3.ACTION = 'SELL'
              AND bs3.AMOUNT > 0
              AND bs3.ID_ITEM = bs.ID_ITEM
              AND bs3.ID_PLAYER = bs.ID_PLAYER
        )
  )
ORDER BY it.NAME, pl.NICKNAME, MONEY_EARNED_OVER_BASE DESC;
*/

-- TRIGGER
BEGIN
    EXECUTE IMMEDIATE 'DROP TRIGGER TRIGGER_1';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -4080 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE TRIGGER TRIGGER_1
AFTER INSERT ON BUY_SELL
FOR EACH ROW
WHEN (NEW.ACTION = 'BUY')
BEGIN
    UPDATE S_STORED
    SET QUANTITY = QUANTITY - :NEW.AMOUNT
    WHERE ID_SHOP = :NEW.ID_SHOP
      AND ID_ITEM = :NEW.ID_ITEM;
    MERGE INTO P_STORED p
    USING (
        SELECT :NEW.ID_PLAYER AS ID_PLAYER,
               :NEW.ID_ITEM AS ID_ITEM
        FROM DUAL
    ) src
    ON (p.ID_PLAYER = src.ID_PLAYER
        AND p.ID_ITEM = src.ID_ITEM)
    WHEN MATCHED THEN
        UPDATE SET p.QUANTITY = p.QUANTITY + :NEW.AMOUNT
    WHEN NOT MATCHED THEN
        INSERT (ID_PLAYER, ID_ITEM, QUANTITY)
        VALUES (src.ID_PLAYER, src.ID_ITEM, :NEW.AMOUNT);
END;
/
--QUERY 1) FARM
SELECT p.ID_PLAYER, p.NICKNAME AS NAME, AVG(pm.END_DATE - pm.START_DATE) AS AVG_TIMESPAN
FROM PLAYER_MISSION pm
JOIN PLAYER p ON p.ID_PLAYER = pm.ID_PLAYER
WHERE pm.IS_COMPLETED = 1 AND pm.END_DATE > pm.START_DATE
GROUP BY p.ID_PLAYER, p.NICKNAME
HAVING AVG(pm.END_DATE - pm.START_DATE) < (
    SELECT AVG(END_DATE - START_DATE)
    FROM PLAYER_MISSION
    WHERE IS_COMPLETED = 1 AND END_DATE > START_DATE
)
ORDER BY AVG_TIMESPAN ASC
FETCH FIRST 10 ROWS ONLY;

--QUERY 2) FARM
SELECT f.ID_FARM, f.SPECIALIZATION, COUNT(*) AS NUM_CROPS
FROM FARM f
JOIN FARMBUILDING fb ON fb.ID_FARM = f.ID_FARM
JOIN CULTIVATIONFIELD cf ON cf.ID_FIELD = fb.ID_FARM_BUILDING
JOIN GROW g ON g.ID_FIELD = cf.ID_FIELD
JOIN CROP c ON c.ID_CROP = g.ID_CROP
WHERE c.QUALITY = 'Gold'
GROUP BY f.ID_FARM, f.SPECIALIZATION
HAVING COUNT(*) = (
    SELECT MAX(GOLD_COUNT)
    FROM (
        SELECT f2.ID_FARM, COUNT(*) AS GOLD_COUNT
        FROM FARM f2
        JOIN FARMBUILDING fb2 ON fb2.ID_FARM = f2.ID_FARM
        JOIN CULTIVATIONFIELD cf2 ON cf2.ID_FIELD = fb2.ID_FARM_BUILDING
        JOIN GROW g2 ON g2.ID_FIELD = cf2.ID_FIELD
        JOIN CROP c2 ON c2.ID_CROP = g2.ID_CROP
        WHERE c2.QUALITY = 'Gold'
        GROUP BY f2.ID_FARM
    )
)
ORDER BY f.ID_FARM;

--FARM QUERY 3)
SELECT 
  a.ID_BARN,
  a.ID_ANIMAL,
  a.NAME_ANIMAL AS ANIMAL_NAME,
  a.AGE,
  a.HEALTH AS HEALTH_STATUS,
  COUNT(p.ID_PRODUCT) AS NUM_PRODUCTS
FROM ANIMAL a
JOIN PRODUCE p ON a.ID_ANIMAL = p.ID_ANIMAL
WHERE a.HEALTH = 'Healthy'
GROUP BY a.ID_BARN, a.ID_ANIMAL, a.NAME_ANIMAL, a.AGE, a.HEALTH
HAVING COUNT(p.ID_PRODUCT) > (
  SELECT AVG(prod_count)
  FROM (
    SELECT COUNT(p2.ID_PRODUCT) AS prod_count
    FROM ANIMAL a2
    JOIN PRODUCE p2 ON a2.ID_ANIMAL = p2.ID_ANIMAL
    WHERE a2.ID_BARN = a.ID_BARN
    GROUP BY a2.ID_ANIMAL
  )
)
ORDER BY a.ID_BARN, a.ID_ANIMAL;

--FARM QUERY 4)
SELECT
  f.ID_FARM,
  f.HECTARES,
  SUM(fb.BUILDING_SIZE) AS OCCUPIED_SPACE,
  f.HECTARES - SUM(fb.BUILDING_SIZE) AS SPACE_LEFT,
  COUNT(*) AS NUM_BUILDINGS,
  FLOOR((f.HECTARES - SUM(fb.BUILDING_SIZE)) / MIN(fb.BUILDING_SIZE)) AS NUM_NEW_BUILDINGS
FROM FARM f
JOIN FARMBUILDING fb ON f.ID_FARM = fb.ID_FARM
GROUP BY f.ID_FARM, f.HECTARES
HAVING f.HECTARES < 600000 AND (f.HECTARES - SUM(fb.BUILDING_SIZE)) > 0
ORDER BY f.ID_FARM;

--FARM QUERY 5)
SELECT
  p.ID_PLAYER,
  p.NICKNAME AS NAME,
  b.ID_BARN AS ID_BARN_BUILDING,
  COUNT(DISTINCT a.ID_ANIMAL_SPECIE) AS SPECIES_COUNT
FROM PLAYER p
JOIN FARM f ON f.ID_PLAYER = p.ID_PLAYER
JOIN FARMBUILDING fb ON fb.ID_FARM = f.ID_FARM
JOIN BARN b ON b.ID_BARN = fb.ID_FARM_BUILDING
JOIN ANIMAL a ON a.ID_BARN = b.ID_BARN
WHERE p.ID_PLAYER NOT IN (
  SELECT DISTINCT ID_PLAYER
  FROM PLAYER_MISSION
  WHERE IS_COMPLETED = 1
)
GROUP BY p.ID_PLAYER, p.NICKNAME, b.ID_BARN
HAVING COUNT(DISTINCT a.ID_ANIMAL_SPECIE) > 1
ORDER BY b.ID_BARN;

--queries for events

--Query events 1)
-- OMNIPRESENCE QUERY - Show people who have attended more events than the average
-- Show their ID, first and last name and the number of events they have attended.
SELECT ID_PERSON, FIRST_NAME, LAST_NAME, EVENT_COUNT
FROM (
  SELECT
    ID_PERSON,
    FIRST_NAME,
    LAST_NAME,
    COUNT(*) AS EVENT_COUNT
  FROM (
    SELECT r.ID_INHABITANT AS ID_PERSON, c.NAME AS FIRST_NAME, NULL AS LAST_NAME
    FROM RESIDENTEVENT re
    JOIN INHABITANT r ON r.ID_INHABITANT = re.ID_RESIDENT
    JOIN CHARACTER c ON c.ID_CHARACTER = r.ID_INHABITANT
    UNION ALL
    SELECT p.ID_PLAYER AS ID_PERSON, c.NAME AS FIRST_NAME, NULL AS LAST_NAME
    FROM RESIDENTEVENT re
    JOIN PLAYER p ON p.ID_PLAYER = re.ID_PLAYER
    JOIN CHARACTER c ON c.ID_CHARACTER = p.ID_PLAYER
  )
  GROUP BY ID_PERSON, FIRST_NAME, LAST_NAME
) stats
WHERE EVENT_COUNT > (
  SELECT AVG(evt_count)
  FROM (
    SELECT COUNT(*) AS evt_count
    FROM RESIDENTEVENT
    GROUP BY ID_RESIDENT
    UNION ALL
    SELECT COUNT(*)
    FROM RESIDENTEVENT
    GROUP BY ID_PLAYER
  )
);

--Query events 2)

SELECT ID, DESCRIPTION, ID_PERSON, NAME, MAX_SPENT
FROM (
  SELECT 
    e.ID AS ID,
    e.DESCRIPTION,
    fs.ID_PERSON,
    fs.NAME,
    fs.TOTAL_SPENT AS MAX_SPENT,
    RANK() OVER (PARTITION BY e.ID ORDER BY fs.TOTAL_SPENT DESC) AS rk
  FROM EVENTS e
  JOIN (
    SELECT ID AS ID_PERSON, SUM(GOLD_EXPENDED) AS TOTAL_SPENT, 'Resident' AS TYPE, NAME AS NAME
    FROM FESTIVITY_PERSONS
    JOIN CHARACTER c ON c.ID_CHARACTER = FESTIVITY_PERSONS.ID_PERSON
    GROUP BY ID, NAME
  ) fs ON fs.ID_PERSON = e.ID
) ranked
WHERE rk = 1
ORDER BY ID;


--Query events 3)
SELECT 
  ID_MUSEUM,
  100 - PERCENTAGE_REMAINING AS STORED_COMPLETION,
  ROUND(100 * COUNT(DISTINCT DONABLE_ITEM) / (SELECT COUNT(*) FROM DONATABLE), 2) AS EXPECTED_COMPLETION,
  ROUND((100 * COUNT(DISTINCT DONABLE_ITEM) / (SELECT COUNT(*) FROM DONATABLE)) - (100 - PERCENTAGE_REMAINING), 2) AS MISSING_PERCENTAGE
FROM MUSEUM_REGISTRY
GROUP BY ID_MUSEUM, PERCENTAGE_REMAINING
HAVING ROUND((100 * COUNT(DISTINCT DONABLE_ITEM) / (SELECT COUNT(*) FROM DONATABLE)), 2) > (100 - PERCENTAGE_REMAINING);

--Query events 4)
SELECT 
  d.ID_PLAYER,
  c.NAME,
  ROUND(100.0 * SUM(CASE WHEN b.ID_BOOK IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*), 2) AS BOOK_PERCENTAGE,
  ROUND(100.0 * SUM(CASE WHEN m.ID_MINERAL IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*), 2) AS MINERAL_PERCENTAGE,
  COUNT(*) AS TOTAL_DONATIONS
FROM DONATION d
JOIN CHARACTER c ON c.ID_CHARACTER = d.ID_PLAYER
LEFT JOIN BOOK b ON b.ID_BOOK = d.ID_DONATABLE
LEFT JOIN MINERAL m ON m.ID_MINERAL = d.ID_DONATABLE
GROUP BY d.ID_PLAYER, c.NAME
HAVING COUNT(*) > 50;


--query events 5)
SELECT
    ID_SHOP,
    SPECIALIZATION,
    ID_ITEM,
    ITEM_NAME,
    PRICE_TO_BUY         AS ORIGINAL_PRICE,
    DISCOUNT             AS DISCOUNT_PCT,
    SAVING               AS ITEM_DISCOUNT
FROM (
    SELECT
        s.ID_SHOP,
        s.SPECIALIZATION,
        it.ID_ITEM,
        it.NAME              AS ITEM_NAME,
        it.PRICE_TO_BUY,
        se.DISCOUNT,
        it.PRICE_TO_BUY
          * se.DISCOUNT
          / 100              AS SAVING,
        ROW_NUMBER() OVER (
            PARTITION BY s.ID_SHOP
            ORDER BY it.PRICE_TO_BUY * se.DISCOUNT DESC,
                     it.ID_ITEM)     AS rn
    FROM   SHOP            s
    JOIN   SELL            se ON se.ID_SHOP = s.ID_SHOP
    JOIN   S_STORED        ss ON ss.ID_SHOP = s.ID_SHOP
    JOIN   ITEM            it ON it.ID_ITEM = ss.ID_ITEM
)
WHERE  rn = 1
ORDER  BY ITEM_DISCOUNT DESC;

--query events 6)
-- Event diversity: Search for the events which have never taken place in the same location
-- Show the ID of the event, the description and location name.
SELECT 
    e.ID_EVENT,
    e.DESCRIPTION,
    p.LOCATION_NAME
FROM EVENT e
    JOIN PLACE p ON p.ID_PLACE = e.ID_PLACE
WHERE e.ID_PLACE IN (
    SELECT ID_PLACE
    FROM EVENT
    GROUP BY ID_PLACE
    HAVING COUNT(DISTINCT ID_EVENT) = 1
)
ORDER BY e.ID_EVENT;


--Query events 7)
-- Trigger to reward players with special items for donating items in "New" condition
-- The special item "Boosts crop growth rate"

BEGIN
    EXECUTE IMMEDIATE 'DROP TRIGGER DONATION_REWARD_TRIGGER';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -4080 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE TRIGGER DONATION_REWARD_TRIGGER
AFTER INSERT ON DONATION
FOR EACH ROW
WHEN (UPPER(NEW.CONDITION_OBJECT) = 'NEW')
BEGIN
    -- Merge the special item into player's inventory
    -- Assuming special item ID for "Boosts crop growth rate" is 9999
    -- (In real implementation, this would be a known item ID from your data)
    MERGE INTO P_STORED p
    USING (
        SELECT :NEW.ID_PLAYER AS ID_PLAYER,
               9999 AS ID_ITEM  -- Special item: "Boosts crop growth rate"
        FROM DUAL
    ) src
    ON (p.ID_PLAYER = src.ID_PLAYER
        AND p.ID_ITEM = src.ID_ITEM)
    WHEN MATCHED THEN
        UPDATE SET p.QUANTITY = p.QUANTITY + 1
    WHEN NOT MATCHED THEN
        INSERT (ID_PLAYER, ID_ITEM, QUANTITY)
        VALUES (src.ID_PLAYER, src.ID_ITEM, 1);
END;
/